{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-166fe6ec5508aea99ec9c6b82afba789e5db8697",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SmartSub.sol": "project/contracts/SmartSub.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SmartSub.sol": {
        "content": "// Author: Manzai-1\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.28;\n\ncontract SmartSub {\n\n    uint256 private nextId;\n    uint256 private owedBalance;\n    bool private locked;\n\n    enum SubState {Active, Paused}\n\n    struct Sub {\n        string title;\n        uint256 durationSeconds;\n        uint256 priceWei;\n        SubState state; \n        address owner; \n    }\n\n    struct User {\n        uint256[] subIds;\n        mapping(uint256 => uint256) subExpirations;\n    }\n\n    mapping(uint256 => Sub) public subs;\n    mapping(address => User) private users;\n    mapping(address => uint256) private balances;\n\n    event SubCreated(\n        string indexed title,\n        address indexed creator,\n        uint256 id\n    );\n    event SubPaused(uint256 indexed id);\n    event SubActivated(uint256 indexed id);\n    event SubPriceUpdated(uint256 id, uint256 priceWei);\n    event SubDurationUpdated(uint256 id, uint256 durationSeconds);\n    event TimeAddedToSub(\n        address indexed receiver,\n        uint256 indexed subId,\n        uint256 newExpiration \n    );\n\n    error NotOwner(address caller);\n    error FunctionNotFound();\n    error PaymentDataMissing();\n    error SubscriptionNotFound();\n    error SubscriptionPaused();\n    error IncorrectValue(uint256 sent, uint256 price);\n    error EmptyBalance();\n    error TransferFailed(uint256 amountWei, address recipient);\n\n\n    modifier subExistsAndIsOwner(uint256 id) {\n        address owner = subs[id].owner;\n        if(owner == address(0)) revert SubscriptionNotFound();\n        if(owner != msg.sender) revert NotOwner(msg.sender);\n        _;\n    }\n\n    modifier subExists(uint256 id) {\n        if(subs[id].owner == address(0)) revert SubscriptionNotFound();\n        _;\n    }\n\n    modifier subExistsAndIsActive(uint256 id) {\n        Sub storage sub = subs[id];\n        if(sub.owner == address(0)) revert SubscriptionNotFound();\n        if(sub.state == SubState.Paused) revert SubscriptionPaused();\n        _;\n    }\n\n    modifier hasBalance() {\n        if(balances[msg.sender] == 0) revert EmptyBalance();\n        _;\n    }\n\n    modifier noReentrancy() {\n        require(!locked, \"Blocked due to re-entrancy risk.\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n\n    constructor () {\n        nextId = 1;\n    }\n\n    fallback() external payable {\n        revert FunctionNotFound();\n    }\n\n    receive() external payable {\n        revert PaymentDataMissing();\n    }\n    \n\n    function createSub (\n        string memory _title,\n        uint256 durationSeconds,\n        uint256 _priceWei,\n        bool activate\n    ) external {\n        uint256 id = nextId++;\n\n        subs[id] = Sub({\n            title: _title,\n            durationSeconds: durationSeconds,\n            priceWei: _priceWei,\n            state: activate ? SubState.Active : SubState.Paused,\n            owner: msg.sender\n        });\n\n        emit SubCreated(_title, msg.sender, id);\n    }\n\n    function activateSub (uint256 id) external subExistsAndIsOwner(id){\n        subs[id].state = SubState.Active;\n        emit SubActivated(id);\n    }\n\n    function pauseSub (uint256 id) external subExistsAndIsOwner(id){\n        subs[id].state = SubState.Paused;\n        emit SubPaused(id);\n    }\n\n    function setSubPrice(uint256 id, uint256 priceWei) external subExistsAndIsOwner(id) {\n        subs[id].priceWei = priceWei;\n        emit SubPriceUpdated(id, priceWei);\n    }\n\n    function setSubDuration(uint256 id, uint256 durationSeconds) external subExistsAndIsOwner(id) {\n        subs[id].durationSeconds = durationSeconds;\n        emit SubDurationUpdated(id, durationSeconds);\n    }\n\n\n    function buySub (uint256 id) external payable subExistsAndIsActive(id) {\n        Sub storage sub = subs[id];\n        uint256 received = msg.value;\n        uint256 price = sub.priceWei;\n\n        if(received != price) revert IncorrectValue(received, price);\n\n        addTime(msg.sender, id, sub);\n        increaseBalance(sub);\n    }\n\n    function giftSub (address receiver, uint256 id) external payable subExistsAndIsActive(id) {\n        Sub storage sub = subs[id];\n        uint256 received = msg.value;\n        uint256 price = sub.priceWei;\n\n        if(received != price) revert IncorrectValue(received, price);\n\n        addTime(receiver, id, sub);\n        increaseBalance(sub);\n    }\n\n    function addTime (address receiver, uint256 id, Sub storage sub) private {\n        User storage user = users[receiver];\n        uint256 expiresAt = user.subExpirations[id];\n\n        if(expiresAt == 0) user.subIds.push(id);\n\n        uint256 addSeconds = sub.durationSeconds;\n        uint256 currentTime = block.timestamp;\n\n        uint256 newExpiration = expiresAt > currentTime ? \n            expiresAt + addSeconds : \n            currentTime + addSeconds;\n\n        user.subExpirations[id] = newExpiration;\n\n        emit TimeAddedToSub(receiver, id, newExpiration);\n    }\n\n    function increaseBalance (Sub storage sub) private {\n        balances[sub.owner] += msg.value;\n        owedBalance += msg.value;\n\n        assert(owedBalance <= address(this).balance);\n    }\n\n    function withdrawBalance () external hasBalance noReentrancy {\n        uint256 amountToTransfer = balances[msg.sender];\n\n        balances[msg.sender] = 0;\n        owedBalance -= amountToTransfer;\n        transferEth(amountToTransfer);\n        \n        assert(owedBalance <= address(this).balance);\n    }\n\n    function transferEth(uint256 amount) private {\n        address recipient = msg.sender;\n\n        (bool ok, ) = payable(recipient).call{value: amount}(\"\");\n        if(!ok) revert TransferFailed(amount, recipient);\n    }\n\n    function viewBalance () external view returns (uint256) {\n        return balances[msg.sender];\n    }\n\n    function isSubActive(uint256 id) external view returns(bool){\n        Sub storage sub = subs[id];\n\n        if(sub.owner == address(0)) revert SubscriptionNotFound();\n        return sub.state == SubState.Active;\n    }\n\n    function isUserSubscribed(address userAddress, uint256 id) external view subExists(id) returns(bool) {\n        uint256 expiration = users[userAddress].subExpirations[id];\n\n        return expiration == 0 ? false : expiration > block.timestamp;\n    }\n\n    function getActiveSubs(address userAddress) \n        external view returns(string[] memory, uint256[] memory, uint256[] memory) \n    {\n        User storage user = users[userAddress];\n        uint256[] storage subIds = user.subIds;\n        uint256 len = subIds.length;\n\n        if(len == 0) return (new string[](0), new uint256[](0), new uint256[](0));\n\n        uint256 currentTime = block.timestamp;\n\n        string[] memory titles = new string[](len);\n        uint256[] memory ids = new uint256[](len);\n        uint256[] memory expirations = new uint256[](len);\n        uint256 activeCount = 0;\n\n        for(uint256 i = 0; i < len; i++) {\n            uint256 subId = subIds[i];\n            uint256 subExpiration = user.subExpirations[subId];\n\n            if(subExpiration > currentTime) {\n                titles[activeCount] = subs[subId].title;\n                ids[activeCount] = subId;\n                expirations[activeCount] = subExpiration; \n                unchecked {\n                    activeCount++;\n                }\n            }\n        }\n\n        assembly {\n            mstore(titles, activeCount)\n            mstore(ids, activeCount)\n            mstore(expirations, activeCount)\n        }\n\n        return(titles, ids, expirations);\n    }\n}"
      }
    }
  }
}